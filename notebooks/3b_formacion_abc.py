# -*- coding: utf-8 -*-
"""3b_formacion_acb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1684otpK1t3q9D2VZdvX9iBc4VsBqPOBr

# **3.b Formación de valores A, B y V**

**Responsable:**

César Zamora Martínez

**Infraestructura usada:** 
Google Colab, para pruebas

## 0. Instalación de Cupy en Colab
"""

!curl https://colab.chainer.org/install | sh -

"""## 1. Implementación

**Consideraciones:**. Esta etapa supone que se conocen $\mu$ y $\Sigma$ asociados a los activos. El fin de este paso es obtener valores escalares que serán relevantes para obtener los pesos del portafolio para el inversionista.

Lo cual, se lleva a cabo en concreto a través de las expresiones:

$$A = \mu^t \cdot \Sigma^{-1} \cdot \mu $$

$$B = 1^t \cdot \Sigma^{-1} \cdot 1 $$

$$C = 1^t \cdot \Sigma^{-1} \cdot \mu $$


En este tenor a continución se presenta el código correspondiente:
"""

import cupy as cp

def formar_abc(mu, Sigma):
  '''
  Calcula las cantidades A, B y C del diagrama de flujo del problema de Markowitz

  Args:
    mu (cupy array, vector): valores medios esperados de activos (dimension n)
    Sigma (cupy array, matriz): matriz de covarianzas asociada a activos (dimension n x n)

  Return:
    A (cupy array, escalar): escalar dado por mu^t \cdot Sigma^-1 \cdot mu
    B (cupy array, escalar): escalar dado por 1^t \cdot Sigma^-1 \cdot 1
    C (cupy array, escalar): escalar dado por 1^t \cdot Sigma^-1 \cdot mu
  '''

  # Vector auxiliar con entradas igual a 1
  n = Sigma.shape[0]
  ones_vector = cp.ones(n)

  # Formamos vector \cdot Sigma^-1 mu y Sigm^-1 1
  # Nota: 
  #   1) u= Sigma^-1 \cdot mu se obtiene resolviendo  Sigma u = mu
  #   2) v= Sigma^-1 \cdot 1 se obtiene resolviendo  Sigma v = 1

  u = cp.linalg.solve(Sigma, mu)
  v = cp.linalg.solve(Sigma, ones_vector)

  # Obtiene escalares de interes
  A = mu.transpose()@u
  B = ones_vector.transpose()@v
  C = ones_vector.transpose()@u

  return A, B, C

"""## 1.1 Matrices de prueba"""

n= 10**4

Sigma=cp.random.rand(n, n)
mu=cp.random.rand(n, 1)

formar_abc(mu, Sigma)