# -*- coding: utf-8 -*-
"""3b_formacion_abc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19An0WS2A8SAuXjIjPUJ-vQNQsS-xiyKe

# **3.b Formación de valores A, B y C**

**Responsable:**

César Zamora Martínez

**Infraestructura usada:** 
Google Colab, para pruebas

## 0. Importamos librerias necesarias

**Fuente:** 3a_formacion_abc.ipynb
"""

!curl https://colab.chainer.org/install | sh -

import cupy as cp

def formar_vectores(mu, Sigma):
  '''
  Calcula las cantidades u = \Sigma^{-1}  \mu y v := \Sigma^{-1} \cdot 1 del problema de Markowitz

  Args:
    mu (cupy array, vector): valores medios esperados de activos (dimension n)
    Sigma (cupy array, matriz): matriz de covarianzas asociada a activos (dimension n x n)

  Return:
    u (cupy array, escalar): vector dado por \cdot Sigma^-1 \cdot mu (dimension n)
    v (cupy array, escalar): vector dado por Sigma^-1 \cdot 1 (dimension n)
  '''

  # Vector auxiliar con entradas igual a 1
  n = Sigma.shape[0]
  ones_vector = cp.ones(n)

  # Formamos vector \cdot Sigma^-1 mu y Sigm^-1 1
  # Nota: 
  #   1) u= Sigma^-1 \cdot mu se obtiene resolviendo  Sigma u = mu
  #   2) v= Sigma^-1 \cdot 1 se obtiene resolviendo  Sigma v = 1

  # Obtiene vectores de interes
  u = cp.linalg.solve(Sigma, mu)
  v = cp.linalg.solve(Sigma, ones_vector)

  return u, v

"""## 1. Implementación

**Consideraciones:**. Esta etapa supone que se conocen $\mu$ y $\Sigma$ asociados a los activos. El fin de este paso es obtener valores escalares que serán relevantes para obtener los pesos del portafolio para el inversionista.

Lo cual, se lleva a cabo en concreto a través de las expresiones:

$$A = \mu^t \cdot \Sigma^{-1} \cdot \mu $$

$$B = 1^t \cdot \Sigma^{-1} \cdot 1 $$

$$C = 1^t \cdot \Sigma^{-1} \cdot \mu $$


En este tenor a continución se presenta el código correspondiente:
"""

import cupy as cp

def formar_abc(mu, Sigma):
  '''
  Calcula las cantidades A, B y C del diagrama de flujo del problema de Markowitz

  Args:
    mu (cupy array, vector): valores medios esperados de activos (dimension n)
    Sigma (cupy array, matriz): matriz de covarianzas asociada a activos (dimension n x n)

  Return:
    A (cupy array, escalar): escalar dado por mu^t \cdot Sigma^-1 \cdot mu
    B (cupy array, escalar): escalar dado por 1^t \cdot Sigma^-1 \cdot 1
    C (cupy array, escalar): escalar dado por 1^t \cdot Sigma^-1 \cdot mu
  '''

  # Vector auxiliar con entradas igual a 1
  n = Sigma.shape[0]
  ones_vector = cp.ones(n)

  # Formamos vector \cdot Sigma^-1 mu y Sigm^-1 1
  # Nota: 
  #   1) u= Sigma^-1 \cdot mu se obtiene resolviendo  Sigma u = mu
  #   2) v= Sigma^-1 \cdot 1 se obtiene resolviendo  Sigma v = 1

  u, v = formar_vectores(mu, Sigma)

  # Obtiene escalares de interes
  A = mu.transpose()@u
  B = ones_vector.transpose()@v
  C = ones_vector.transpose()@u

  return A, B, C

"""## 1.1 Matrices de prueba"""

n= 10**2

Sigma=cp.random.rand(n, n)
mu=cp.random.rand(n, 1)

formar_abc(mu, Sigma)